### 从零搭建微服务框架嗷

新建webapi项目

![image-20201026181939602](从零搭建微服务框架学习文档.assets/image-20201026181939602.png)

新建student控制器，测试运行

![image-20201026182245668](从零搭建微服务框架学习文档.assets/image-20201026182245668.png)

![image-20201026182254921](从零搭建微服务框架学习文档.assets/image-20201026182254921.png)

添加新项目控制台应用程序，加入model类

![image-20201026182407678](从零搭建微服务框架学习文档.assets/image-20201026182407678.png)

![image-20201026182436593](从零搭建微服务框架学习文档.assets/image-20201026182436593.png)

![image-20201026182536295](从零搭建微服务框架学习文档.assets/image-20201026182536295.png)

删除program.cs文件，右键属性，修改输出类型为“类库”

![image-20201026182552213](从零搭建微服务框架学习文档.assets/image-20201026182552213.png)

继续新建项目，interface，作为服务的接口

![image-20201026183008099](从零搭建微服务框架学习文档.assets/image-20201026183008099.png)

删除program.cs文件，继续修改属性为类库

定义完了接口，接下来应该定义实现接口的具体服务了，新建控制台应用程序

编写DBhelper类，原生连接数据库

添加StudentService实现类，继承IStudentService，实现它未实现的方法

![image-20201026183509062](从零搭建微服务框架学习文档.assets/image-20201026183509062.png)![image-20201026183523894](从零搭建微服务框架学习文档.assets/image-20201026183523894.png)

依然重复上述步骤，右键属性，修改输出类型为类库

测试，以上依然是个单体结构，只不过分层了，现在我们搭了基层结构如图：

![image-20201026183657453](从零搭建微服务框架学习文档.assets/image-20201026183657453.png)

分别为，webapi，接口，模型层，接口实现类

接下来修改webapi内student控制层里的方法，尝试调用通过接口调用服务，进而获取数据库中的数据

修改前：

![image-20201026183803906](从零搭建微服务框架学习文档.assets/image-20201026183803906.png)

修改后：

先在startup.cs中进行服务类的依赖注入

![image-20201026184259317](从零搭建微服务框架学习文档.assets/image-20201026184259317.png)

在这里，我们对controller进行重新构造：

定义一个私有只读IStudentService接口 ； 

在构造函数里为它赋值

在GetAllStu方法里进行调用

![image-20201026184627518](从零搭建微服务框架学习文档.assets/image-20201026184627518.png)

启动试试，输入url

![image-20201026184827682](从零搭建微服务框架学习文档.assets/image-20201026184827682.png)

不错不错

接下来我们要添加服务实例，将原来的单体应用程序，模拟拆分成分布式应用程序

新建项目，新建webapi

![image-20201026185004596](从零搭建微服务框架学习文档.assets/image-20201026185004596.png)

新建新的控制器，为了和上面的student控制器区分，且，我们要知道，最后上面将作为客户端，调用我们现在正在搭建的服务实例，这个项目，所以真正会和接口、服务、数据库打交道的应该在我们现在搭建的这个控制器里面，在这里我取名为StuImplController控制器。

![image-20201026185242569](从零搭建微服务框架学习文档.assets/image-20201026185242569.png)

在这里面，复制之前的studentcontroller里的内容，作为真正调用的源头

![image-20201026185405390](从零搭建微服务框架学习文档.assets/image-20201026185405390.png)

同时，别忘记了，要正常使用，记得在该项目内startup.cs中增加依赖注入![image-20201026185548164](从零搭建微服务框架学习文档.assets/image-20201026185548164.png)

修改启动项目为该服务实例，我们先试试看能不能跑

![image-20201026190458520](从零搭建微服务框架学习文档.assets/image-20201026190458520.png)

nice

接下来我们做分布式应用程序：我们希望LjsMicroServiceReviewDemo通过ServiceInstance去调用，这样子，前者就可以作为客户端，后者就可以作为服务端，因为是进程间通信，虽然在一台电脑上跑，但是可以理解为是利用网络架起的桥梁，进行分布式应用的部署和调用。

这时候记录一下网址

http://localhost:42464/api/StuImpl/GetAllStu

![image-20201026190938569](从零搭建微服务框架学习文档.assets/image-20201026190938569.png)

在客户端，写一个调用方法，调用刚刚的网址嘿嘿

同时启动两个项目，让他搞去吧

![image-20201026191036770](从零搭建微服务框架学习文档.assets/image-20201026191036770.png)

![image-20201026191232782](从零搭建微服务框架学习文档.assets/image-20201026191232782.png)

爽爆了！

但是还不够，我们知道，一般情况下，服务器里怎么可能只有一个服务实例在跑呢，那双十一不是炸裂，所以这时候会有很多实例在跑才对，例如两个、三个相同的实例一起运行，同时对外提供服务才对。

我们要使用命令行运行服务实例，并且赋予相应的端口号

![image-20201026193900248](从零搭建微服务框架学习文档.assets/image-20201026193900248.png)

![image-20201026194428606](从零搭建微服务框架学习文档.assets/image-20201026194428606.png)

![image-20201026194845947](从零搭建微服务框架学习文档.assets/image-20201026194845947.png)

在地址栏敲cmd

![image-20201026194856720](从零搭建微服务框架学习文档.assets/image-20201026194856720.png)

![image-20201026194903514](从零搭建微服务框架学习文档.assets/image-20201026194903514.png)

![image-20201026194909623](从零搭建微服务框架学习文档.assets/image-20201026194909623.png)

开启三个服务实例，端口为5726、5727、5728

为了验证，可以在浏览器试试

![image-20201026195019372](从零搭建微服务框架学习文档.assets/image-20201026195019372.png)

nice

这时候，客户端调用的url就得改成上述网址了

![image-20201026195131547](从零搭建微服务框架学习文档.assets/image-20201026195131547.png)

你有种调用我试试

![image-20201026195809734](从零搭建微服务框架学习文档.assets/image-20201026195809734.png)

可是我们做不到负载均衡呀，就是我们不晓得怎么调用5726还是5727还是5728嘞，这时候就要引入Nginx啦！

下载Nginx和环境变量的配置就不过多赘述了

![image-20201026195315199](从零搭建微服务框架学习文档.assets/image-20201026195315199.png)

修改conf文件

![image-20201026195409611](从零搭建微服务框架学习文档.assets/image-20201026195409611.png)

配置端口侦听

配置代理端口号

最后我们打算舍弃传统的调用方式，寄希望于Nginx反向代理工具来帮我们实现一些负载均衡的策略

启动Nginx.exe

![image-20201026195704107](从零搭建微服务框架学习文档.assets/image-20201026195704107.png)

启动客户端程序，跑一跑

![image-20201026195954175](从零搭建微服务框架学习文档.assets/image-20201026195954175.png)

问题不大，但是这时候又有个问题了，如果某个服务突然挂了怎么办呢，如果有个服务因为预计可能会有大规模的访问，运维人员又加上了几个服务实例呢，这时候就需要我们手动在conf的配置文件里进行配置，这样十分的低效，假如你在一家超大型的互联网公司，就GG了，所以这时候我们要用consul来替代Nginx

nuget包必不可少

![image-20201026200233953](从零搭建微服务框架学习文档.assets/image-20201026200233953.png)

同样在服务实例项目里也要引入consul包

在服务实例项目中，加入帮助类，心跳检测控制器，并在startup.cs中配置

在ReviewDemo中也要注册并使用

配置完毕后要激活consul，重新生成才行

![image-20201026202449309](从零搭建微服务框架学习文档.assets/image-20201026202449309.png)![image-20201026202508759](从零搭建微服务框架学习文档.assets/image-20201026202508759.png)

启动成功，接着让三个服务实例上线

![image-20201026204217548](从零搭建微服务框架学习文档.assets/image-20201026204217548.png)

![image-20201026204225424](从零搭建微服务框架学习文档.assets/image-20201026204225424.png)

其实这时候我们不知道如何做负载均衡，如果要做的话，也带在客户端做负载均衡，这样每个客户端都要做一个，就很麻烦，没有什么是加一层不能解决的，所以我们加一层服务网关，Ocelot，用于请求分发、统一负载均衡、熔断、限流、降级

![image-20201026204426653](从零搭建微服务框架学习文档.assets/image-20201026204426653.png)

我们继续创建新项目：webapi

![image-20201026204640378](从零搭建微服务框架学习文档.assets/image-20201026204640378.png)

引入nuget包，ocelot用于服务网关，consul用于网关和注册中心的集成，polly用于熔断、限流、降级等

当然，在服务实例层也要加入ocelot.provider.consul，否则ocelot怎么知道服务实例从哪里来呢对吧，好了我们再回到gateway层

在program.cs文件中添加配置的json文件

![image-20201026204959449](从零搭建微服务框架学习文档.assets/image-20201026204959449.png)

在startup.cs文件中把管道换成ocelot自己的

![image-20201026205138653](从零搭建微服务框架学习文档.assets/image-20201026205138653.png)

配置文件

![image-20201026205802408](从零搭建微服务框架学习文档.assets/image-20201026205802408.png)

给她一个运行端口

![image-20201026205827534](从零搭建微服务框架学习文档.assets/image-20201026205827534.png)

跑一跑

![image-20201026205837308](从零搭建微服务框架学习文档.assets/image-20201026205837308.png)

结束了嗷，下个阶段的内容应该是，CQRS命令查询职责分离，以及以及以及数据库如何划分，以及以及以及Rabbitmq以及基于事件的驱动。