### 计算机组成原理学习文档

CPU

内存

硬盘

主板

计算机硬件识别数据

高低电平0/1

通过电信号传递数据

金属针脚：传递电信号用的通道

通过很多条电路，可以传递多个二进制数位，每个二进制数位称为1bit比特



文字、数字、图像如何用二进制表示

如何存储二进制数

CPU如何对二进制数字进行加减乘除

如何从内存中取出想要的数据

CPU如何识别和执行我们写的程序



计算机系统 = 硬件 + 软件

硬件是计算机的实体，软件由具有各类特殊功能的程序组成

计算机性能的好坏取决于软硬件功能的总和



软件

- 系统软件：用来管理整个计算机系统
  - 操作系统、DBMS、标准程序库、网络软件、语言处理程序、服务程序

- 应用软件
  - 按照任务需要编制成的各种程序

硬件的发展

第一台电子数字计算机 ENIAC1946 冯诺依曼

逻辑元件：电子管



第一代：电子管时代 纸带机编程

第二代：晶体管 开始出现操作系统 开始出现高级语言

第三代：中小规模集成电路 高级语言迅速发展 开始出现分时操作系统

第四代：大规模、超大规模集成电路  出现微处理器、微型计算机、个人计算机PC萌芽 、 操作系统 



微处理器的发展：

机器字长：计算机一次整数运算所能处理的二进制位数



摩尔定律：揭示了信息技术进步的速度，集成电路上可容纳的晶体管数目，约每隔18个月就会增加一倍，整体性能也将提升一倍



软件的发展：

机器语言010101=>汇编语言=>FORTRAN/PASCAL/C++=>java、python



DOC操作系统=>windows、android、ios



目前的发展趋势：

两极分化：

1.微型计算机更微型化、网络化、高性能、多用途方向发展

2.巨型化、超高速、并行处理、智能化方向发展



计算机硬件的基本组成：

1.早期冯诺依曼的结构

2.现代计算机的结构

ENIAC手动接线来控制计算

冯诺依曼：”存储程序“的概念是指将指令以二进制代码的形式事先输入计算机的主存储器（内存），然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。



早期冯诺依曼机：

数据/程序：即软件 

硬件：

输入设备：将信息转换成机器能识别的形式

存储器：存放数据和程序

运算器：算术运算和逻辑运算

控制器：指挥程序运行

输出设备：将结果转换成人们熟悉的形式



在计算机系统中，软件和硬件在逻辑上是等效的。



冯诺依曼计算机的特点：

- 计算机由5大部件组成：输入设备、输出设备、存储器、运算器、控制器
- 指令和数据以同等地位存储于存储器，可按地址寻访
- 指令和数据用二进制表示
- 指令由操作码和地址码组成
- 存储程序
- 以运算器为中心

输入/输出设备与存储器之间的数据传送通过运算器完成



现代计算机的结构以存储器为中心

CPU=运算器+控制器

计算机组成原理中，主机的概念就是运算器+控制器（cpu）+存储器

存储器：主存（内存）+辅存（硬盘）

主机的存储器是内存也就是主存

辅存是IO设备



计算机硬件的基本组成：

- 五大部分
  - 输入设备：将信息转换成机器能识别的形式
  - 输出设备：将结果转换成人们熟悉的形式
  - 主存储器：存放数据和程序
  - 运算器：算术运算、逻辑运算
  - 控制器：指挥各部件，使程序运行
- 冯诺依曼结构
  - 首次提出存储程序概念
  - 以运算器为中心
- 现代计算机结构
  - 以存储器为中心
  - CPU=运算器+控制器



主存储器的基本组成：

主存储器：

- 存储体
- MAR  memory address register 存储地址寄存器
- MDR  memory data register  存储数据寄存器

读和写



存储器：

- 存储单元：每个存储单元存放一串二进制代码
- 存储字：word 存储单元中二进制代码的组合
- 存储字长：存储单元中二进制代码的位数
- 存储元：存储二进制的电子原件，通常为电容，每个存储元可存1bit

MAR位数反映存储单元的个数

MDR位数=存储字长

MAR4位 = 一共有2的四次方个存储单元

MDR16位 = 每个存储单元可存放16bit 1个字word = 16bit



混淆点

1个字节=8bit

1B=一个字节 

1b=1bit



运算器的基本组成：用于实现算术运算和逻辑运算

- ACC  accumulator 累加器 用于存放操作数或运算结果
- MQ multiple-quotient register 乘商寄存器 ， 在乘除运算时，用于存放操作数或运算结果
- ALU arithmetic and logic unit 算术逻辑单元， 通过内部复杂的电路实现算术运算、逻辑运算
- X 通用的操作数寄存器， 用于存放操作数



控制器的基本组成：

- CU： control unit控制单元，分析指令，给出控制信号
- IR： instruction register 指令寄存器，存放当前执行的指令
- PC： program counter 程序计数器 ， 存放下一条指令地址， 有自动加1功能

完成一条指令=取指令PC + 分析指令 IR + 执行指令CU



各硬件部件：

- 主存
  - MAR：内存地址寄存器，用于指明要读/写哪个存储单元。其位数反映存储单元的数量
  - MDR：内存数据寄存器，用于暂存要读/写的数据。其位数反映存储字长
  - 存储体: 概念：存储元、存储单元、存储字、存储字长、地址
- 运算器
  - X 通用寄存器，存放操作数
  - ACC 累加计数器，存放操作数、运算结果
  - ALU 算术逻辑单元，用电路实现各种算术运算、逻辑运算
  - MQ 乘商寄存器，进行乘除法时用到
- 控制器
  - IR 指令寄存器，存放当前执行的指令
  - PC 程序计数器，存放下一条指令的地址
  - CU 控制单元，分析指令，给出控制信号
- 工作过程
  - 初始：指令、数据存入主存，PC指向第一条指令
  - 从主存中取指令放入IR、PC自动加1、CU分析指令、CU指挥其他部件执行指令



计算机系统的层次结构

- 高级语言机器 用编译程序翻译成汇编语言程序
- 汇编语言机器 用汇编程序翻译成机器语言程序
- 操作系统机器 向上提供广义指令(系统调用)

- 用机器语言的机器 执行二进制机器指令
- 微指令系统 由硬件直接执行微指令



三种级别的语言

- 高级语言
- 汇编语言
- 机器语言

通常高级语言得翻译成汇编语言，汇编语言翻译成机器语言才可以执行

但有时候高级语言可以直接通过编译程序直接翻译成机器语言进行执行



编译程序：编译、汇编、解释程序

解释程序的语言就是解释性语言

编译的语言就是编译性语言



编译程序是一次全部翻译成机器语言的程序，而后再执行机器语言程序，只需要翻译一次

解释程序是将源程序的一条语句翻译成对应于机器语言的语句并立即执行。紧接着再翻译下一句，每次执行都要翻译



计算机的性能指标

存储器的性能指标

MAR位数反映存储单元的个数（对多支持多少个）

MDR位数=存储字长=每个存储单元的大小

总容量=存储单元个数*存储字长 bit = 存储单元个数 * 存储字长/8 byte

2的十次方 = K

2的二十次方=M

2的三十次方=G

2的四是次方=T



CPU的性能指标

CPU主频：CPU内部数字脉冲信号振荡的概率 = 1/CPU时钟周期

CPI:执行一条指令所需的时钟周期

执行一条指令的耗时：CPI * CPU 时钟周期

CPU执行时间：整个程序的耗时

IPS： instructions per second 每秒执行多少条指令 = 主频/平均CPI

FLOPS:每秒执行多少次浮点运算



系统整体的性能指标

数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）

吞吐量：系统在单位时间内处理请求的数量

响应时间：用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。

基准程序：用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其他计算机性能进行比较。



计算机的性能指标：

- 存储器的容量
  - MAR的位数反映存储单元数量
  - MDR反映每个存储单元大小
- CPU
  - 主频 时钟频率 =1/时钟周期 单位:HZ
  - 时钟周期 CPU中的最小单位，每个动作至少要一个时钟周期
  - CPU执行时间 
    - 运行一个程序所花费的时间
    - 指令条数 * CPI /主频
  - CPI 执行一条指令所需的时钟周期数
  - IPS 每秒执行多少条指令 =主频/平均CPI
  - FLOPS：每秒执行多少浮点运算
- 其他
  - 数据通路宽度、吞吐量、响应时间、基准程序
- 常用数量单位
  - 描述存储容量、文件大小时：K=2^10 M=2^20 G=2^30 t=2^40
  - 描述频率、速率时：K=10^3 M=10^6 G=10^9 T=10^12



进位计数制

- 十进制、二进制、八进制、十六进制
- 其他进制=>十进制
- 二进制、八进制、十六进制之间的相互转换
- 十进制=>其他进制
- 真值和机器数



基数：每个数码位所用到的不同符号的个数，r进制的基数为r

二进制：0,1

八进制：01234567

十进制：0123456789

十六进制：0123456789ABCDEF



二进制优势：

1. 可以使用两个稳定状态的物理器件表示
2. 01正好对应逻辑值的假真。方便实现逻辑运算
3. 可以很方便地使用逻辑门电路实现算术运算



任意进制=>十进制

二进制=>八进制、十六进制



二进制基数为2

八进制基数为8

为了保证对应，应该将二进制的3位作为一组，每组转换位对应的八进制符号



八进制=>二进制

八进制基数为8

二进制基数为2

为了保证对应，应该将八进制的每位都用二进制的三位来代替，每3为转换位对应的二进制符号



二进制表示 10101010B

十六进制 349820347H 0x2234623876

十进制 2134234D



十进制=>二进制 使用   （整数部分）除基取余法+（小数部分）乘基取整法



真值：符合人类习惯的数字

机器数：数字实际存到机器里的形式，正负号需要被数字化



BCD码：Binary-Coded Decimal ,用二进制编码的十进制

- 8421码
- 余三法
- 2421码

原理：用4个二进制来表示一个十进制 ， 虽然这样会造成6种冗余，因为2的四次方=16 即能表示从0-15 ， 十进制表示从0-9 ， 所以会造成6个冗余



8421码对应关系：

X X X X

8 4 2 1 

所以如果想表示985 ， 8421码应该这么写 1001 1000 0101 嘻嘻嘻！

十进制的加法 8+5 

8421码加法 8+5 = 1000 + 0101 = 1101 但是这个落在1010~10010中，也就是8421码不允许或者说没有定义的范围内，为了让他有意义，需要+6，让它进一位，也即1101+0110 = 11011 = 0001 0011 也就是1 3 



余3码：8421码+（0011）B



2421码：改变权值定义

X X X X

2 4 2 1

如果想表示985 ， 则 1111 1110 1011 

规则：0-4 第一位不能为1 ；  5-9 第一位必须为1



BCD码

- 8421码
  - 每4个二进制位对应一个十进制位（有6个冗余状态）
  - 8、4、2、1分别对应每一位的权值
  - 0000-1011 分别对应 0-9 ，进行加法后若超出该范围，则需要+0110B进行修正（强制向高位进1）
- 余3码
  - 8421码 + 0011
- 2421码
  - 2、4、2、1分别对应每一位的权值
  - 表示0~4时最高位为0 ， 表示5~9时最高位为1



字符与字符串

英文表示

ASCII码

128位字符 用7位来表示就好 ，但1B=8bit 通常就用1B来表示一个字符

可印刷字符：32-126 ， 其余为控制、通信字符



  97=01100001B

122=01110110B

汉字表示

为了方便区分 ， 将1980版国标列出了常用的7000多个汉字，对应的是一个93 * 93 的矩阵，用矩阵的行和列来表示，即区码+位码

区位码：94个区，每区94个位置

但是前文提到ASCII码的0-32是用于控制和通信，为了防止汉字的编码和英文的编码产生冲突，我们需要在原有的基础上+20H （20H就是十六进制的20 ， 也就是32） 加上32之后就避开了通信和控制区域 ， 但是ASCII码32-125是可印刷字符，为了防止汉字的编码和英文的编码产生冲突，我们需要在原有的基础上+80H（80H就是十六进制的128）这样就可以越开ASCII码产生的冲突，因为ASCII码是1B，并且1B是以0xxx xxxx 表示的，高位不是1，但汉字的区位码，分为区码和位码，加上20H和80H之后，高位必然是1，如果高位是1，就代表他是汉字不是英文字符，所以要读两个B，也就是2B，所以为什么英文符号是1个字节而中文符号是2个字节了。



汉字的输入：输入编码 例如nei2

汉字的输出：汉字字形码



字符串:某计算机按字节编址，编址即每个地址对应1B，从地址为2的单元开始，存储字符串为“abc",那么，2-5的地址分别存，61H   62H   63H  00H（\0） 最后一行使用'\0'作为字符串结尾标识

当存放”abc啊“的时候，因为汉字需要占用2B，所以2-6的地址分别存， 61H    62H   63H   B0H   A1H   00H 或者 61H   62H   63H   A1H   B0H   00H   ，

大端模式：将数据的最高有效字节存放在低地址单元中

小端模式：将数据的最高有效字节存放在高地址当中



字符与字符串

- ASCII码
  - 通常用8bit表示一个字符，最高位都为0
  - 共128个字符。0-31为控制/通信字符；32-126为可印刷字符
  - 所有大写字母、所有小写字母、所有数字的编码都连续
- 汉字
  - 区位码、国标码、汉字内码、输入编码、字形码
  - 国标码=区位码+2020H
  - 机内码=国标码+8080H
- 字符串
  - 从低地址到高地址逐个字符存储，常采用'\0'作为结尾标志
  - 对于多字节的数据（如汉字），可采取大/小端存储模式
  - 大端模式：将数据的最高有效字节存放在低地址单元中
  - 小端模式：将数据的最高有效字节存放在高地址单元中



奇偶校验码

奇偶校验

- 校验原理
- 奇偶校验

由若干位代码组成的一个字叫码字

将两个码字逐位进行对比，具有不同的位的个数成为两个码字间的距离

一种编码方案可能有若干个合法码字，各合法码字间的最小距离成为码距

当码距=1时，无检错能力 ； 当码距=2时，有检错能力 ； 当码距>=3时，若设计合理，可能具有检错纠错能力



奇校验码：整个校验码（有效信息位和校验位）中1的个数为奇数

偶校验码：整个校验码（有效信息位和校验位）中1的个数为偶数



奇偶校验中，如果偶数个位发生位错误，也就是位跳变的话是检测不出错误的



如何求校验位：

求偶校验位：对有效信息位进行异或运算，算的结果就是偶校验位的值

如何进行校验：对偶校验来说，如果进行的是异或运算得到的结果是1就说明出错了



海明校验码

设计思路：将信息位分组进行偶校验=>多个校验位=>多个校验位标注出错位置

多个校验位能够携带多种状态信息（对/错，错在哪里）



1.确定海明码的位数：2^k >=n+k+1

k代表多少位校验码

n代表有效信息位

2.确定校验位应该放在哪个位置

将校验位放在海明位号为2^i-1次方的位置上

3.确定校验位将和那几个有效位组成一组

假设信息位：1010

将一共有多少位从高到低排列，如H7 H6 H5 H4 H3 H2 H1 

将7654321转成二进制的数表示

即0111 0110 0101 0100 0011 0010 0001  

找出有效位，也就是7653，也就是

H7:    0111

H6:    0110

H5:    0101

H3:    0011

从尾巴开始对为1的有效位的**实际值**进行异或运算，得到每个校验位的值以及和那些有效位作为一组

即P1=H7异或H5异或H3=D4异或D2异或D1=1异或1异或0=0

即P2=H7  H6  H3 = D4  D3  D1  = 1  0  0  = 1 

即P3=H7  H6  H5 = D4  D3  D2  = 1  0  1  = 0

| H7   | H6   | H5   | H4   | H3   | H2   | H1   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| D4   | D3   | D2   | P3   | D1   | P2   | P1   |
| 1    | 0    | 1    |      | 0    |      |      |

分组结果就是：

P1 D4 D2 D1

P2 D4 D3 D1

P3 D4 D3 D2

4.纠错

纠错就是对分组进行偶校验，若为1就说明有问题

异或的结果从高到低排列 010 =>十进制就是2 ，就代表第二位出错了



海明码的检错、纠错能力:

纠错能力--1位

检错能力--2位

为了防止出现2位同时出现位错误判断错误位不对的情况，我们需要在前头加上全校验位，对整体进行偶校验

1.若S3S2S1为000并且全体偶校验成功=>无错误

2.若S3S2S1不为0并且全体偶校验失败=>有一位错误，纠正就可以了

3.若S3S2S1不为0并且全体偶校验码成功=>有两位错误，需要重传



海明码

- 基本思想
  - 分组偶校验，多个校验位可反映出错位置
- 求解步骤
  - 确定校验位个数k个校验位，n个信息为
    - 2^k>=n+k+1
  - 确定校验位分布
    - P1、P2、P3...分别在123416
    - 空出来的其他位置一次填入信息位
  - 求校验位
    - 将信息位的位置序号用k位二进制数表示出来
    - 校验位Pi 与位置序号第i位为1的信息为归为一组，进行偶校验
  - 纠错
    - 对P1、P2、P3...所属各分组进行异或（相当于分组偶校验）求得S1、S2、S3
    - S3 S2 S1 = 000 说明无错误
    - S3 S2 S1 不等000 其值反映出错位置

- 补充
  - 海明码有1位纠错，2位检错能力
  - 为了区分1位错和2位错，还需添加“全校验位”对整体进行偶校验



循环冗余校验码

基本思想：数据发送、接受方约定一个“除数”

K个信息位+R个校验位 作为“被除数” ， 添加校验位后需保证除法的余数为0

若余数非0 说明出错，则进行重传或纠错

- 构造
  - 由生成多项式确定除数。若生成多项式中x的最高次为R，则除数有R+1位
  - K个信息位+R个0 ， 作为被除数
  - 被除数、除数 进行模二除 ，得到R为余数
  - K个信息位+R位余数 = CRC码
- 校验
  - 收到K+R位数据，与生成多项式模二除，计算R为余数
  - 余数为0，说明无错误
  - 余数非0，说明出错
- 检错、纠错能力
  - 可以检测出所有奇数个错误
  - 可以检测出所有双比特的错误
  - 可以检测出所有小于等于校验位长度的连续错误
  - 若选择合适的生成多项式，且2^R >=K +R +1，则可纠正单比特错



定点数与浮点数

定点数：小数点的位置固定   --常规计数法

浮点数：小数点的位置不固定  --科学计数法



定点数的表示

- 无符号数
- 有符号数
  - 原码
  - 反码
  - 补码
  - 移码



无符号数：整个机器字长的全部二进制均为数值位，没有符号位，相当于数的绝对值。

8位二进制数：2的八次方种不同状态，可以表示的是0到2的八次方-1这么多的十进制数。

n为的无符号数表示范围为：0到2的n次方-1的十进制



有符号数的定点表示：

定点整数+定点小数

最高位为符号位

数值部分称为尾数



注：可用原码、反码、补码三种方式来表示定点整数和定点小数。还可用移码表示定点整数。

符号位0表示正数1表示负数



原码：用尾码表示真值的绝对值，符号位0/1 ， 对应正负

若机器字长为n+1位，则尾数占n位

若机器字长为n+1位，原码整数的表示范围为：-（2^n-1)到2^n-1

真值0有+0 和 -0 两种形式



若机器字长为n+1位，原码小数的表示范围为-（1-2^-n）到1-2^-n

真值0有+0 和 -0 两种形式



反码：若符号位为0，则反码与原码相同

​			若符号位为1，则数值位全部取反



补码：正数的补码=原码

​			负数的补码=反码+1



移码：补码的基础上将符号位取反。注意：移码只能用于表示整数



移码表示的整数很方便对比大小



各种码的作用

加减运算：

无符号数的运算结果没有任何问题

但是用原码表示有符号数的话，需要先判断符号位是不是负数，如果是负数的话，需要将负数的位改成正数位，然后将加法运算改成减法运算

也即，使用原码运算：

加法--用加法器完成

减法--用减法器完成



但减法器成本很高，所以考虑用加法来代替减法运算



带余除法----设x，m属于z，m>0则存在唯一决定的整数q和r，使得：x=qm+r  ， 0<=r<m



实际上就是将整数分成r类，每类分别为余数从0到r-1

模数相同的都是同一类，都是等价的



二者绝对值之和=模的，互为补数

模-a的绝对值=a的补数

在mod m  的条件下，若能找到负数的补数，就可以用正数的加法来等价替代减法



如果模数m为12的话，那么也就是余数0-11

如果计算机的字长为8bit，也就是表示的范围是0-2^8-1，那么也就是实际上模数就是2^8呗

所以只要模-a的绝对值=a的补数   =>  2^8-a的绝对值=a的补数  => a的补码形式的原生定义



补码---就是让减法操作转变为加法操作，节省硬件成本 ， 这样ALU中只需要设计加法运算器就可以啦



补码的作用：使用补码可将减法操作转变为等价的加法，ALU中无需集成减法器。执行加法操作时，符号位一起参与运算。----《数论》



移码的作用：移码表示的整数很方便的对比大小



定点数的表示和运算

- 表示
  - 无符号数
  - 有符号数
    - 原码
    - 补码
    - 反码
    - 移码
- 运算
  - 移位运算
  - 加减运算
  - 乘法运算
  - 除法运算



移位运算

- 算数移位
  - 原码
  - 补码
  - 反码
- 逻辑移位
- 循环移位



原码   1 0010100.   ==-20

小数点位置是无法改变的，但是我们可以巧妙的改变数的位置，也就是

原码   1 0001010. 也就是将尾数，整体右移一位，左边多出来的可以补0    ==-10

原码的算数移位：符号位保持不变，仅对数值位进行移位

右移：高位补0，低位舍弃。若舍弃的位=0，则相当于除2；若舍弃的位不等于0，则会丢失精度

左移：低位补0，高位舍弃。若舍弃的位=0，则相当于乘2；若舍弃的位不等于0，则会出现严重误差



反码的算数移位--正数的反码与原码相同，因此对正数反码的移位运算也和原码相同。

右移：高位补0，低位舍弃。

左移：低位补0，高位舍弃。



反码的算数移位--负数的反码数值位与原码相反，因此负数反码的移位运算规则如下，

右移：高位补1，低位舍弃

左移：低位补1，高位舍弃



补码的算数移位--正数的补码与原码相同，因此对正数补码的移位运算也和原码相同。

右移：高位补0，低位舍弃。

左移：低位补0，高位舍弃。



补码的算数移位--负数补码=反码末位+1导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。

规律--负数补码中，最右边的1及其右边和原码相同。最右边的1的左边和反码相同

所以，负数补码的算数移位规则如下：

右移（同反码）：高位补1，低位舍弃

左移（同原码）：低位补0，高位舍弃



牛到家的例子

-20*7

可以理解为-20*（4+2+1）

也就是-20左移两位，左移1位，和不移位三者之和



逻辑移位：

逻辑右移：高位补0，低位舍弃

逻辑左移：低位补0，高位舍弃

可以把逻辑移位看作是对无符号数的算数移位



循环移位：

循环左移和带进位位的循环左移

应用：汉字的大端模式和小端模式相互转换的时候



定点数移位运算

- 算数移位
  - 左移1位相当于x基数；右移以为相当于/基数
  - 原码：符号位不参与移位。左移右移都补0
  - 反码：符号位不参与移位。左移右移都补1
  - 补码：负数补码的最右边的1及其右边与源码相同，最右边的1的左边与反码相同。符号位不参与移位，左移补0，右移补1。
- 逻辑移位
  - 左移、右移都补0，移出的位舍弃。
- 循环移位
  - 不带进位位：用移出的位补上空缺
  - 带进位位：移出的位放到进位位，原进位位补上空缺

注：由于原、反、补码的数位有限，因此某些时候算数移位不能精确等效乘法、除法



加减运算

- 原码的加减法
- 补码的加减法
- 溢出判断
- 符号扩展



原码的加法运算：

正+正：绝对值做加法，结果为正，可能溢出

负+负：绝对值做加法，结果为负，可能溢出

正+负：绝对值大的减绝对值小的，符号同绝对值大的数

负+正：绝对值大的减绝对值小的，符号同绝对值大的数



原码的减法运算，“减数”符号取反，转变为加法：

正-负：正+正

负-正：负+负

正-正：正+负

负+正：负-负



太难了用减法器

所以考虑用补码的加减运算



负数补码=>原码：

- 数值位取反+1
- 负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码

对于补码来说，无论加法还是减法，最后都会转变为加法，由加法器实现运算，符号位也参与运算



当数太大的时候，可能会发生溢出，所以要进行溢出判断



溢出判断

- 只有正数+正数才会上溢-----正+正=负
- 只有负数+负数才会下溢-----负+负=正



方法1：采用一位符号位 设A的符号位As，B的符号位Bs，运算结果的符号为Ss，则溢出逻辑表达式为

V=AsBs（非Ss）+（非As）（非Bs）Ss

若V=0，表示无溢出

若V=1，表示有溢出



方法2：采用一位符号位，根据数据位进位情况判断溢出，符号位的进位Cs 最高数值位的进位C1

上溢：Cs=0，C1=1

下溢：Cs=1，C1=0

用异或来判断就好



方法3：采用双符号位

正数符号为00，负数符号为11

记两个符号位为Ss1，Ss2，则V=Ss1异或Ss2

若V=0，则表示无溢出，若V=1，表示有溢出



双符号位补码称为：模4补码

单符号位补码称为：模2补码



符号扩展

由于可能会出现溢出，所以可以考虑补位，即int->long ， 如8位=>16位



定点整数的符号扩展：

在原符号位和数值位中间添加新位，正数都添0；负数原码添0，负数反、补码添1

定点小数的符号扩展：

在原符号位和数值位中间添加新位，正数都添0,；负数原码、补码添0，负数反码添1



加减运算：

- 原码
  - 加法
  - 减法
- 补码：总是要转变成加法，符号位参与运算
- 溢出判断（补码）
  - Key：正+正=负（上溢）；负+负=正（下溢）
  - 方法三：采用双符号位，正数符号为00，负数符号为11，加法运算后若双符号位=01则发生上溢错误；若双符号位为10则发生下溢错误，若两个符号位相同，则未发生错误
- 符号扩展
  - 定点整数符号的扩展：在原符号位和数值位中间添加新位，正数都添0，负数原码添0，反码添1，补码添1
  - 定点小数符号的扩展：在原符号为和数值位后面添加新位，正数都添0，负数原码、补码添0，反码添1



乘法运算

- 乘法运算的实现思想
- 原码的一位乘法
- 补码的一位乘法



手算乘法：可以考虑用移位来实现，左移就是乘法，右移就是除法

考虑用机器来实现：

- 实际数字有正负，符号位如何处理
- 乘积的位数扩大一倍如何处理
- 4个位积都要保存下来最后统一相加吗？



原码一位乘法

符号单独处理：符号位=xs和ys进行异或操作

数值位进行相乘就好了



运算器：

ALU：算术逻辑单元

X：通用寄存器（存放被乘数）

ACC：累加、存放乘积高位

MQ：存放乘数和乘积低位

机器字长为n+1

实现方法：先加法再移位，重复n次



首先，ACC置为0，X存被乘数，MQ存乘数

当前位=1，则ACC加上被乘数

当前位=0，则ACC加0

如此再通过移位运算，达到错位的效果



补码的乘法运算

原码的一位乘法：

进行n轮加法、移位

每次加法可能是+0、+x的原码

每次移位是逻辑右移

符号位不参与运算

符号位最后由一个异或运算来决定



补码的一位乘法：

进行n轮加法、移位，最后再多来一次加法

每次加法可能+0，+x的补码，+-x的补码

每次移位是补码的算数右移

符号位参与运算



辅助位-MQ中的最低位=1，ACC+x的补码

辅助位-MQ中的最低位=0，ACC+0

辅助位-MQ中的最低位=-1，ACC+-x的补码



除法运算

- 除法运算的思想
- 原码除法：恢复余数法
- 原码除法：加减交替法（不恢复余数法）
- 补码除法：加减交替法



恢复余数法：

实现方法：上商0/1，得到余数，余数末尾补0



强制类型转换：

无符号数与有符号数：

不改变数据内容，改变解释方式



长整数变短整数：

高位截断，保留低位



短整型变长整数：

符号扩展



大小端模式：

大端模式：便于人类阅读

小段模式：便于机器处理



边界对齐

现代计算机通常是按字节编址，每个字节对应1个地址

通常也支持按字、按半字、按字节寻址

假设存储字长为32位，则1个字为=32bit ，半字=16bit  每次仿存只能读写1个字



边界不对齐



边界对齐访问一个字/半字都只需要一次访存 ， 即空间换时间，舍弃空间，换取最佳时间

边界不对齐访问一个字/半字可能需要两次访存，即时间换空间，舍弃时间，换取空间密度最佳



浮点数的表示

- 浮点数的表示
  - 浮点数的作用和基本原理
  - 浮点数规格化
  - 浮点数的表示范围
- IEEE 754标准
- 浮点数的加减运算



定点数的局限性：

定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度



如何在位数不变的情况下增加数据的表示范围



阶码+尾数

阶码=阶符+阶码的数值部分

尾数=数符+尾数的数值部分



浮点数的表示

定点数：如纯小数0.1011和纯整数11110

浮点数：阶码+尾数

阶码：常用补码或移码表示的定点整数

尾数：常用原码或补码表示的定点小数



浮点数的真值：N=r的E次方*M

阶码的底通常为2

阶码E反映浮点数的表示范围及小数点的实际位置；

尾数M 的数值部分的位数n反映浮点数的精度



之所以叫做浮点数，正是由于小数点可以通过阶码的值来对尾数进行调整，从而看起来像小数点在尾数中浮动，因此叫浮点数



浮点数尾数的规格化

使得尾数的最高位是有效值（左规），以免丢失精度



规格化浮点数：规定尾数的最高数值位必须是一个有效值

左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码则要减1

右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算数右移一位，阶码加1



注：采用双符号位，当溢出发生时，可以挽救。更高的符号位是正确的符号位



浮点数的表示范围也有极限

浮点数的表示

- 表示
  - 阶码：阶符+数值部分，尾数：数符+数值部分
  - 阶码+尾数
    - 尾数给出具体数值，阶码指明小数点前移、后移多少位
    - 阶码通常是用补码、移码表示的定点整数
    - 尾数通常是用补码、原码表示的定点小数
    - 真值：N=r的E次方*M

- 规格化
  - 尾数的最高数值位必须是一个有效值（类比十进制科学计数法，通常我们会让数值部分最高位为非0）
  - 左规：数值位最高位无效时，通过尾数算数左移、阶码-1的方法处理，直到尾数最高数值位有效时停止
  - 右规：若采用双符号位表示尾数，则当运算后尾数假溢出时，可以通过尾数右移、阶码+1的方法处理
  - 原码表示的尾数规格化：尾数的最高数值位必须是1
  - 补码表示的尾数规格化：尾数的最高数值位必须和尾数符号位相反
- 表示范围



浮点数标准

IEEE754



移码：补码基础上将符号位取反。注意：移码只能用于表示整数

移码的定义是：移码=真值+偏置值

以往的偏置值通常是2的n-1次方



在IEEE754标准中，偏置值将设定为2的n-1次方-1

那么移码就会有一点点改变



分为数符、阶码部分（用移码表示）、尾数（用原码表示，隐藏表示最高位）



阶码全1、全0用作特殊用途



浮点数的运算

- 加减运算
- 强制类型转换



1.对阶

2.尾数加减

3.规格化

4.舍入

5.判溢出



char->int->long->double

float->double

范围、精度从小到大，转换过程没有损失

32位

int：表示整数

float：表示整数及小数

因此，int->float:可能损失精度

float->int:可能溢出及损失精度



算数逻辑单元

- 作用、大致原理
- 电路基础知识
- 加法器的实现

ALU:MQ ACC ALU X PSW



基本逻辑运算：与或非

优先级：与>或

分配律结合律都满足的



复合逻辑：与非、或非、异或、同或

加法器：



一位全加器：

Ai+Bi+Ci-1=Si和Ci

Ai是一个输入

Bi是一个输入

Ci-1是来自低位的进位

Si是本位的输出

Ci是来自本位的进位



串行加法器：

只有一个全加器，数据诸位串行送入加法器中进行运算。进位触发器用来寄存进位信号，以便参与下一次运算。



并行加法器：

串行进位的并行加法器：把n个全加器串接起来，尽可以进行两个n位数的相加。

串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。



算数逻辑单元：

- ALU
  - 实现算术运算、逻辑运算、辅助功能（移位、求补）
  - 基本结构：输入、输出、控制CU
- 电路基础知识
  - 逻辑运算：与或非、与非、或非、异或、同或
  - 门电路：最基础的逻辑元件，用于实现逻辑运算
  - 逻辑表达式就是电路的数学化表示。根据逻辑运算的规则对逻辑表达式进行优化，也就是在优化电路
- 加法器的实现
  - 一位全加器的设计
    - 本位和Si=Ai异或Bi异或Ci-1
    - 本位向高位的进位Ci=AiBi+（Ai异或Bi）Ci-1
  - 串行加法器
    - 一位全加器+进位触发器，只能一位一位地加
  - 串行进位的并行加法器
    - 多个全加器简单串联，可多位同时相加
    - 计算速度取决于进位产生和传递的速度

- 回忆
  - 各种门电路的图形，全加器的图形和输入输出信号



并新加法器的优化

并行进位的并行加法器：各级进位信号同时形成，又称为先行进位、同时进位



串行加法器=>串行进位的并行加法器=>组内并行、组件串行进位的加法器=>组内并行、组件并行进位的加法器 



系统总线

总线的基本概念

总线的分类

总线特性及性能指标

总线结构

总线控制



总线是连接各个部件的信息传输线，是各个部件共享的传输机制。

总线上信息的传送

串行-----

并行----

----

总线结构

1.单总线结构框图

缺点：总线会成为瓶颈

2.面向CPU的双总线结构框图

CPU和主存之间加入M总线

3.以存储器为中心的双总线结构框图



总线的分类

1.片内总线：芯片内部的总线

2.系统总线：计算机各部件之间的信息传输线

- 数据总线：双向   与机器字长、存储字长有关
- 地址总线：单向   与存储地址、IO地址有关
- 控制总线：有出有入

3.通信总线

用于计算机系统质检或计算机系统与其他系统之间的通信

传输方式

- 串行通信总线
- 并行通信总线



总线特性及性能指标

1.总线的物理实现

实际上就是印刷电路板：主板

2.总线特性

- 机械特性		尺寸、形状、管脚数、排列顺序
- 电气特性        传输方向和有效的电平范围
- 功能特性        每根传输线的功能：地址、数据、控制
- 时间特性        信号的时序关系

3.总线的性能指标

- 1.总线宽度	数据线的根数

- 2.标准传输率  	每秒传输的最大字节数（MBps）

- 3.时钟同步、异步		同步、不同步

- 4.总线复用	 	地址线与数据线复用

- 5.信号线数		地址线、数据线和控制线的总和

- 6.总线控制方式		突发、自动、仲裁、逻辑、计数

- 7.其他指标		负载能力

4.总线标准

ISA EISA VESA PCI AGP RS-232 USB



总线结构

- 单总线结构
- 多总线结构
  - 双总线结构
    - 主存总线+通道+IO总线
    - CPU和主存之间加入M总线
  - 三总线结构
    - 主存总线、IO总线、DMA总线（IO设备和主存直接访问）
    - CPU和cache之间的局部总线+系统总线+扩展总线
  - 四总线结构
    - 局部总线+系统总线+高速总线+扩展总线
- 多层PCI总线结构



总线控制

总线判优控制

主设备：对总线有控制权

从设备：响应从主设备发来的总线命令

总线判优控制：

- 集中式
  - 链式查询
  - 计数器定时查询
  - 独立请求方式
- 分布式



链式查询：

BS--总线忙

BR--总线请求

BG--总线同意

bg的判断是串行的，所以是叫链式查询



计数器定时查询：

计数器放在总线控制部件内部，当可以让出总线占用权的时候，轮流向IO接口通过**设备地址**进行访问，少了BG总线，多了设备地址线，更加灵活设定优先级顺序



独立请求方式：

排队控制总线中设有排队器

发起总线请求的时候，总线控制部件同时对外发起总线占用请求



总线通信控制：

1.目的：解决通信双方协调配合的问题

2.总线传输周期

- 申请分配阶段	主模块申请，总线仲裁决定
- 寻址阶段      主模块向从模块给出地址和命令
- 传数阶段     主模块和从模块交换数据
- 结束阶段      主模块撤销有关信息



总线通信的四种方式

- 同步通信     由统一时标控制数据传送
- 异步通信     采用应答方式，没有公共时钟标准
- 半同步通信    同步、异步结合
- 分离式通信      充分挖掘系统总线每个瞬间的潜力



同步式数据输入

总线传输周期有四个

在不同时钟周期上升沿给出信号

在第一个时钟上升沿，给出地址信号

在第二个时钟上升沿，给出读命令

在第三个时钟上升沿，给出写数据信号

在第四个时钟上升沿，撤销读命令以及写数据信号

在第五个时钟上升沿，撤销地址信号



同步式数据输出



适用于总线比较短，不同模块读写速度近似的



异步通信：

主设备和从设备的请求和回答

分为：不互锁、半互锁和全互锁方式



半同步通信（同步、异步结合）

同步：发送方用系统时钟前沿发信号，接收方用系统时钟后沿判断、识别

异步：允许不同速度的模块和谐工作，增加一条“等待”响应信号



T1 主模块发地址

T2 主模块发命令

Tw 当WAIT为低电平时，等待一个T

Tw 当WAIT为低电平时，等待一个T

当WAIT为高电平时，主模块开始向从模块对接

T3 从模块提供数据

T4 从模块撤销数据，主模块撤销命令



以上三种通信的共同点：

一个总线传输周期中:

- 主模块发地址、命令		占用总线
- 从模块准备数据   不占用总线 总线空闲
- 从模块向主模块发送数据   占用总线



第四种则是在总线空闲的时候，充分法诀系统总线每个瞬间的潜力，也就是分离式通信

一个总线传输周期中，主模块申请占用总线，使用完后即放弃总线的使用权，在从模块准备好数据的时候，申请占用总线，将各种信息送至总线上



分离式通信特点

- 各模块有权申请占用总线
- 采用同步方式通信，不等对方回答
- 各模块准备数据时，不占用总线
- 总线被占用时，无空闲



存储器

主存储器和高速缓冲存储器很重要



- 存储器可分哪些类型
- 现代存储器的层次结构，为什么要分层



存储器分类

- 按照存取方式分类

  - 存取时间与物理地址无关（随机访问）
    - 随机存储器    在程序的执行过程中可读可写
    - 只读存储器    在程序的执行过程中只读
  - 存取时间与物理地址有关（串行访问）
    - 顺序存取存储器		磁带
    - 直接存取存储器        磁盘

- 按在计算机中的作用分类

  - 主存储器
    - RAM 随机存储器 可读可写
      - 静态RAM
      - 动态RAM
    - ROM只读存储器  系统程序 不允许修改
      - MROM
      - PROM
      - EPROM
      - EEPROM
  - Flash Memory 例如U盘、固态
  - 高速缓冲存储器（Cache）

  - 辅助存储器：磁盘、磁带、光盘

- 存储介质分类

  - 半导体存储器	TTL、MOS   易失
  - 磁表面存储器     磁头、载磁体   不易失
  - 磁芯存储器      硬磁材料、环状元件   不易失
  - 光盘存储器    激光、磁光材料   不易失

  

  存储器的层次结构

  1. 存储器的三个主要特性的关系

  速度、容量、价格

  

  

  ​				寄存器			CPU	主机						速度快			容量小			价格高

  ​				缓存				CPU	主机

  ​				主存							主机	

  ​				磁盘										辅存

  ​				光盘										辅存

  ​				磁带										辅存			速度慢			容量大			价格低

  

  软件、硬件相结合，多种存储器结合的形式，使得某一级的程序员看来，高速、大容量、低价格

  2.缓存--主存层次和主存--辅存层次

  CPU    缓存	主存	辅存

  10ns    20ns	200ns	ms

  缓存--主存   是由硬件绑定在一块儿的（主要为了解决速度问题）

  主存--辅存   是由软硬件结合的形式弄在一块儿的（主要为了解决容量问题）

  

  缓存--主存

  - 主存储器的地址
  - 实地址
  - 物理地址

  主存--辅存

  - 虚拟存储器
  - 虚地址
  - 逻辑地址

  

  主存储器--概述

  - 主存的基本组成
  - 主存与CPU之间的联系
  - 主存中的存储单元地址的分配
  - 主存的技术指标

  

  基本组成

  MAR地址寄存器

  译码器

  驱动器

  存储体

  读写电路

  控制电路

  MDR数据寄存器

  

  主存和CPU的联系 

  MDR----数据总线（双向）----主存

  CPU----读写---主存

  MAR---地址总线（单向）---主存

  

  主存中存储单元地址的分配

  高位字节放在前边---大端模式、大尾模式

  低位字节放在前边---小端模式、小尾模式

  

  主存的技术指标

  - 存储容量	主存存放二进制代码的总位数
  - 存储速度
    - 存取时间		存储器的访问时间   读出时间    写入时间
    - 存取周期        连续两次独立的存储器操作（读或写）所需的最小间隔时间    读周期、写周期
  - 存储器的带宽      位/秒

  

  半导体存储芯片简介

  1.半导体存储芯片的基本结构

  译码驱动+存储矩阵+读写电路

  除此之外还有交互的数字线路，例如地址线（单向）、数据线（双向）、片选线、读写控制线

  

  地址线实际上是地址个数，例如地址线10条，也就是有2的10次方个地址

  数据线实际上是数据的位数，例如数据线有4条，也就是有4位的0101来表示一个数据

  所以芯片容量=地址线*数据线

  

  片选线   非CS   非CE   chipselect  chipenable  低电平有效

  读写控制线   非WE 写  非OE  读

  

  存储芯片片选线的作用

  用16K*1位的存储芯片组成64K * 8位的存储器

  那么就要求同时对8个芯片进行操作，每个芯片凑一个一位，8个同时工作就凑足8位，并且要同时凑足4组，因为1组只有2的16次方个地址，只有凑足4组才能够2的64次方这么多地址

  因此片选线的作用就是让几个存储芯片连接在一起同时工作

  

  半导体存储芯片的译码驱动方式

  1.线选法  通过输入的地址线，通过地址译码器来判断哪根线有效，然后将有效的线上的数据通过读写控制电路，也就是数据线输出，缺点在于如果地址线位数很多，那么也就是地址线需要很多，每根地址线要和不同的控制电路的块块相连，那么就会导致线很多

  2.重合法	线选法使用矩阵来布线，而重合法使用二维矩阵来布线，布线的数量大大降低

  

  随机存取存储器RAM

  - 静态RAM（SRAM）
    - 保存0和1的原理是什么
      - 通过触发器来实现存取，这部分涉及到数电的内容
    - 基本单元单元电路的构成是什么		
    - 对单元电路如何读出和写入
      - 通过片选信号将不同的芯片分组，通过重合法和地址线以及数据线，对低电平的地址进行选中后进行读写操作
    - 典型芯片的结构是什么样子的
    - 静态RAM芯片如何进行读出和写入操作

  - 动态RAM(DRAM)

    - 保存0和1的原理是什么
      - 存在电容中，有电就是1，没电就是0
  
    - 基本单元单元电路的构成是什么		
    - 对单元电路如何读出和写入
    - 典型芯片的结构是什么样子的
      - 单管、三管
    - 静态RAM芯片如何进行读出和写入操作
    - 动态RAM为什么要进行刷新，刷新方法
      - 防止电子丢失，刷新与行地址有关
      - 集中刷新（存在死区和死时间率）
      - 分散刷新（刷新过快了，没有死区）
      - 集中刷新与分散刷新相结合（异步刷新）
  
- 动态RAM和静态RAM的比较

  ​				DRAM				SRAM

存储原理        电容                  触发器

集成度            高                          低

芯片引脚        少                           多

功耗                小                           大

价格				低							高

速度				慢							快

刷新				有							无

​				用作主存					用作缓存



只读存储器ROM

早起只读存储器----不能修改

改进1----用户可以自己写------一次性

改进2-----可以多次写-------要能对信息进行擦除

改进3------电可擦写-------特定设备

改进4------电可擦写-------直接连接到计算机



1.掩模ROM（MROM）

行列选择线交叉处有MOS管为1

2.PROM一次性编程

3.EPROM（多次性编程）

N型沟道浮动栅MOS电路

紫外线擦除







